### 解题思路
#### 解法一：遍历

在第一链表上（m个结点），首先确定一个，然后在第二链表（n个结点）遍历所有，看有没有
如果没有，第一链表移动为下一个

时间复杂度O（mn）

#### 解法二：利用数据的特点
相同结点的后面都是相同的结点

因此可以从最后一个开始比较
比较到最后一个相同的时候即为链表相交的第一个结点

实现方法，可以设置两个堆栈，顺序放入，然后弹出比较

空间复杂度O（m+n）
时间复杂度O（m+n）

空间换时间

#### 解法三：先减去多余长度
链表如果长度不等，将长的链表先走多余的长度个结点
使两个链表剩余元素相同

然后在分别判断下面的结点是否相同
第一个相同的即为所求

时间复杂度O(m+n)
不需要辅助空间